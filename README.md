# Тестовое задание для стажёра Backend
# Сервис динамического сегментирования пользователей

### Проблема:

В Авито часто проводятся различные эксперименты — тесты новых продуктов, тесты интерфейса, скидочные и многие другие.
На архитектурном комитете приняли решение централизовать работу с проводимыми экспериментами и вынести этот функционал в отдельный сервис.

### Задача:

Требуется реализовать сервис, хранящий пользователя и сегменты, в которых он состоит (создание, изменение, удаление сегментов, а также добавление и удаление пользователей в сегмент)

**Сценарии использования:**

Хотим провести несколько экспериментов и протестировать новый функционал Авито:
- Голосовые сообщения в чатах
- Новые услуги продвижения
- Скидка 30% на услуги продвижения
- Скидка 50% на услуги продвижения

> Кто из пользователей в какой эксперимент попадет будет решать большой отдел аналитики, а мы лишь дадим им возможность для таких тестов.

Допустим аналитики создали сегменты:
- AVITO_VOICE_MESSAGES
- AVITO_PERFORMANCE_VAS
- AVITO_DISCOUNT_30
- AVITO_DISCOUNT_50

и добавили созданные сегменты нескольким пользователям:

| Пользователь | Сегменты которым он принадлежит |
| --- | --- |
| 1000 | [AVITO_VOICE_MESSAGES, AVITO_PERFORMANCE_VAS, AVITO_DISCOUNT_30, …] |
| 1002 | [AVITO_VOICE_MESSAGES, AVITO_DISCOUNT_50, …] |
| 1004 | нет сегментов |

> Формат хранения данных в базе данных не ограничен - можно выбрать любой удобный

**Получили следующие данные:**

- Пользователь 1000 состоит в 3 сегментах: AVITO_VOICE_MESSAGES, AVITO_PERFORMANCE_VAS, AVITO_DISCOUNT_30

- Пользователь 1002 состоит в 2 сегментах: AVITO_VOICE_MESSAGES, AVITO_DISCOUNT_50

- Пользователь 1004 не состоит ни в одном из сегментов

Теперь мы хотим через API сервиса по user_id получать список сегментов в которых он состоит.

## Требования и детали по заданию

**Технические требования:**

1. Сервис должен предоставлять HTTP API с форматом JSON как при отправке запроса, так и при получении результата.
2. Язык разработки: Golang.
3. Фреймворки и библиотеки можно использовать любые.
4. Реляционная СУБД: MySQL или PostgreSQL.
5. Использование docker и docker-compose для поднятия и развертывания dev-среды.
6. Весь код должен быть выложен на Github/Gitlab с Readme файлом с инструкцией по запуску и примерами запросов/ответов (можно просто описать в Readme методы, можно через Postman, можно в Readme curl запросы скопировать, и так далее).
7. Если есть потребность в асинхронных сценариях, то использование любых систем очередей - допускается.
8. При возникновении вопросов по ТЗ оставляем принятие решения за кандидатом (в таком случае в Readme файле к проекту должен быть указан список вопросов, с которыми кандидат столкнулся и каким образом он их решил).
9. Разработка интерфейса в браузере НЕ ТРЕБУЕТСЯ. Взаимодействие с API предполагается посредством запросов из кода другого сервиса. Для тестирования можно использовать любой удобный инструмент. Например: в терминале через curl или Postman.

**Будет плюсом:**

1. Покрытие кода тестами.
2. [Swagger](https://swagger.io/solutions/api-design/) файл для вашего API.

**Основное задание (минимум):**

1. Метод создания сегмента. Принимает slug (название) сегмента.
2. Метод удаления сегмента. Принимает slug (название) сегмента.
3. Метод добавления пользователя в сегмент. Принимает список slug (названий) сегментов которые нужно добавить пользователю, список slug (названий) сегментов которые нужно удалить у пользователя, id пользователя.
4. Метод получения активных сегментов пользователя. Принимает на вход id пользователя.

**Детали по заданию:**

1. По умолчанию сервис не содержит в себе никаких данных о сегментах и пользователях (пустая табличка в БД). Данные появляются при создании сегментов и добавлении их пользователям.
2. Валидацию данных и обработку ошибок оставляем на ваше усмотрение.
3. Список полей к методам не фиксированный. Перечислен лишь необходимый минимум. В рамках выполнения доп. заданий возможны дополнительные поля.
4. Механизм миграции не нужен. Достаточно предоставить конечный SQL файл с созданием всех необходимых таблиц в БД.
5. Сегменты пользователя очень важны - на этих данных в будущем строится аналитика о том насколько продукт востребован. Поэтому нужно следить за тем чтобы сегменты не терялись (не перетирались) и не добавлялись лишним пользователям.
6. Мы можем добавлять сегменты пользователю динамически (он уже состоит в нескольких, мы можем добавить еще несколько, не перетирая существующие).
7. В методе получения сегментов пользователя мы должны получить АКТУАЛЬНУЮ информацию о сегментах пользователя с задержкой не более 1 минуты после добавления сегмента.

## Опциональные задания

Далее перечислены дополнительные задания.

Они не являются обязательными, но их выполнение даст существенный плюс перед другими кандидатами.

Можно выбрать несколько из представленных

*Доп. задание 1:*

Иногда пользователи приходят в поддержку и спрашивают почему у них пропал/появился какой-то новый функционал. Нужно иметь возможность посмотреть когда точно пользователь попал в конкретный сегмент.

Задача: реализовать сохранение истории попадания/выбывания пользователя из сегмента с возможностью получения отчета по пользователю за определенный период. На вход: год-месяц. На выходе ссылка на CSV файл.

Пример отчета:

идентификатор пользователя 1;сегмент1;операция (добавление/удаление);дата и время

идентификатор пользователя 1;сегмент2;операция (добавление/удаление);дата и время

идентификатор пользователя 2;сегмент3;операция (добавление/удаление);дата и время

*Доп. задание 2:*

Бывают ситуации когда нам нужно добавить пользователя в эксперимент на ограниченный срок. Например выдать скидку всего на 2 дня.

Задача: реализовать возможность задавать TTL (время автоматического удаления пользователя из сегмента)

Пример: Хотим чтобы пользователь попал в сегмент на 2 дня - для этого в метод добавления сегментов пользователю передаём время удаления пользователя из сегмента отдельным полем

*Доп. задание 3:*

Мы хотим добавлять пользователя в сегмент не в ручную, а автоматически. В сегмент будет попадать заданный процент пользователей.

Задача: в методе создания сегмента, добавить опцию указания процента пользователей, которые будут попадать в сегмент автоматически. В методе получения сегментов пользователя, добавленный сегмент должен отдаваться у заданного процента пользователей.

Пример: создали сегмент AVITO_VOICE_MESSAGES и указали что 10% пользователей будут попадать в него автоматически. Пользователь 1000 попал в этот сегмент автоматически. При запросе сегментов пользователя 1000, сегмент AVITO_VOICE_MESSAGES должен отдаваться всегда.

# Как запустить

Переименовываем файл `.env.example` в `.env`

В корневой папке проекта прописываем `docker-compose up`

После прохождения постгресом хэлсчека, сервис запустится на порту `8080` и будет готов принимать запросы. Проверить работоспособность можно, например, открыв `http://localhost:8080/swagger/`, с помощью чего должен открыться доступ к Swagger UI

# Схема БД

Схема БД описана в файле, находящемся в папке [`initdb`](https://github.com/PoorMercymain/user-segmenter/tree/main/initdb) в корне проекта

# Тесты

![изображение](https://github.com/PoorMercymain/user-segmenter/assets/67076111/55ee0637-baa1-41c6-b754-0d8f28df08be)

Для проверки покрытия тестами можно использовать команду `go test -cover`, запущенную из корня проекта

# Вопросы, с которыми столкнулся
1. ID - всегда число? Ответ: не обязательно, ID в принципе может содержать другие символы, так что это строка

2. В какую сторону округлять число юзеров при подсчете процента для добавления в сегмент? Ответ: вниз, так как мы не хотим добавлять сегменты лишним пользователям

3. Как хранить сегменты пользователей? Ответ: скорее всего, сегментов гораздо меньше, чем число юзеров, так что можно хранить отдельным полем у пользователя его сегменты, т.к. в противном случае придется каждый раз при запросе получения сегментов пробегаться по огромным таблицам, что иногда может быть довольно медленным процессом

4. Как реализовать TTL сегментов пользователя? Ответ: возможно, не очень элегантное/оптимальное решение, но для того, чтобы данные о удалениях меньше терялись (что иногда происходило бы при передаче через каналы, например при перезапусках сервиса) и не переусложнять задачу (что было бы при использовании для этого, например, кафки), я решил просто сделать горутину, которая раз в N секунд просыпается и удаляет сегменты у пользователей

5. JSON в технических требованиях ограничивает выбор http методов? Ответ: нет, просто нужно чтобы хотя бы некоторые из эндпойнтов принимали JSON. Например, метод получения активных сегментов - явно должен быть GET, а не POST

6. Загружать ли в репозиторий сгенерированные файлы? Ответ: да, так будет удобнее

# Примеры запросов

Примеры некоторых запросов можно найти в [postman коллекции](https://github.com/PoorMercymain/user-segmenter/blob/main/user-segmenter.postman_collection.json)
Примеров запросов чтения отчетов там нет, т.к. для них нужно знать название сгенерированного файла, а оно заранее неизвестно. По сути для того, чтобы проверить этот запрос нужно выполнить другой - для генерации отчета, после чего в body ответа будет ссылка для чтения файла

- **Swagger**

    `http://localhost:8080/swagger/`

    ![изображение](https://github.com/PoorMercymain/user-segmenter/assets/67076111/dac7e048-d8bb-4717-a1e3-a959fcc4d5f3)

    Данный адрес можно использовать для доступа к Swagger UI. Файлы для swagger лежат в папке [docs](https://github.com/PoorMercymain/user-segmenter/tree/main/docs), находящейся в корне проекта

- **Запрос создания сегмента**

    `POST http://localhost:8080/api/segment`

    ![Картинка с примером запроса создания сегмента](https://github.com/PoorMercymain/user-segmenter/assets/67076111/d2a0a163-e51e-49a1-85f3-f6c29dd88427)

    Принимает название сегмента

    ![Картинка с некорректным запросом](https://github.com/PoorMercymain/user-segmenter/assets/67076111/6bf5d700-96d8-4806-926a-bac116e55a9a)

    Если передан не slug отправляет статус код Unprocessable Entity

    ![Картинка с некорректным форматом запроса](https://github.com/PoorMercymain/user-segmenter/assets/67076111/480815a0-bf18-47bb-baf1-c932ca9a2d0c)

    Если запрос некорректен (например в нем дублирующиеся поля, поля, которые в запросе не ожидаются, JSON с ошибками синтаксиса) отправляет статус код Bad Request

    ![Картинка с попыткой добавить уже существующий сегмент](https://github.com/PoorMercymain/user-segmenter/assets/67076111/a4cfe92e-288a-41c1-b514-41f1394752c7)

    Если сегмент уже добавлен, то при повторном добавлении отправляет статус код Conflict

    Если произошла внутренняя ошибка сервера - возвращает Internal Server Error

- **Запрос создания сегмента с автоматическим добавлением заданного процента пользователей в него**

    `POST http://localhost:8080/api/segment`

    ![Картинка с примером запроса создания сегмента](https://github.com/PoorMercymain/user-segmenter/assets/67076111/6eeed433-193f-4e0e-8962-4d55ee2c18cb)

    Данный запрос также проверяет, чтобы процент не был отрицательным или больше ста. При успешном выполнении выдает Accepted, т.к. может потребоваться добавить много пользователей, и поэтому их добавление производим асинхронно

    ![Картинка с попыткой добавить сегмент, с некорректным процентом пользователей](https://github.com/PoorMercymain/user-segmenter/assets/67076111/1ae992a9-65ff-4d0c-98cf-f92741a3e5ba)

    На картинке процент 150, поэтому вернулся статус код Bad Request

    ![Картинка с попыткой добавить сегмент, с некорректным процентом пользователей](https://github.com/PoorMercymain/user-segmenter/assets/67076111/3e32ae10-f5e1-4bcd-b3e0-9f7622355714)

    Отрицательный процент - тоже Bad Request

- **Запрос удаления сегмента из списка доступных**

    `DELETE http://localhost:8080/api/segment`

    ![Картинка с примером запроса удаления сегмента](https://github.com/PoorMercymain/user-segmenter/assets/67076111/16540e62-244e-4f40-99cf-da1b60977e91)

    Принимает название сегмента и при успешном выполнении отправляет статус код Accepted (т.к. при удалении сегмента нам еще нужно удалить его у всех юзеров, что может занять какое-то время, в связи с этим выполняем удаление асинхронно)

    ![Картинка с запросом удаления несуществующего сегмента](https://github.com/PoorMercymain/user-segmenter/assets/67076111/36760dbf-5fac-4761-a552-b4df658f8d74)

    Если переданный сегмент не существует - статус код Not Found

    ![Картинка с некорректным форматом запроса](https://github.com/PoorMercymain/user-segmenter/assets/67076111/65e4eaee-0db3-4d3a-8939-d909734533a9)

    Также, как и в первом случае, при некорректном запросе отправляет Bad Request. В данном случае было передано поле `s`, которое не ожидалось

    При внутренней ошибке сервера отправляет Internal Server Error

- **Запрос обновления (добавления, удаления) сегментов пользователя**

    `POST http://localhost:8080/api/user`

    ![Запрос добавления пользователя](https://github.com/PoorMercymain/user-segmenter/assets/67076111/c87b2195-2321-4296-a6ec-705cb5f6ed27)

    Обязательное поле - `user_id` (строка, не число), поэтому статус код OK. Запрос по данному эндпойнту также позволяет добавлять и удалять пользователей из сегментов

    ![Запрос добавления пользователя в сегменты](https://github.com/PoorMercymain/user-segmenter/assets/67076111/ea56a7c1-a224-4887-84c1-d7cb7d878c57)

    В поле `slugs_to_add` передается список существующих сегментов для добавления пользователю

    ![Некорректный запрос добавления пользователя в сегменты](https://github.com/PoorMercymain/user-segmenter/assets/67076111/5df582f3-1db5-45a4-93e8-99968cd04371)

    Сегмент `SEG` не был добавлен с помощью запроса создания сегмента, поэтому на такой запрос выдается Not Found

    ![Запрос добавления с удалением](https://github.com/PoorMercymain/user-segmenter/assets/67076111/8aa7c1f1-ce4f-440c-9743-3ac9635bdc33)

    В поле `slugs_to_delete` передается список сегментов, в которых состоит пользователь, для удаления

    ![Некорректный запрос удаления пользователя из сегмента](https://github.com/PoorMercymain/user-segmenter/assets/67076111/2e5a9cf4-5a0f-4943-8d4f-f26bcea3d399)

    Сегмент `SEG` не был добавлен пользователю, поэтому при попытке его удалить выдается Not Found

    Bad Request и Internal Server Error как у первого эндпойнта

- **TTL сегментов пользователя**

    `POST http://localhost:8080/api/user`

    ![Запрос с TTL сегментов](https://github.com/PoorMercymain/user-segmenter/assets/67076111/9afdd70a-25d2-4f4e-b3e6-97c264fd3c1e)

    TTL сегментов передается списком, число элементов которого должно совпадать с числом элементов списка на добавление (т.е. если добавляем 2 сегмента, и хотим указать TTL - указываем 2 времени, а не только 1). Время должно быть указано согласно такому формату (пример для 31 августа 2023 года 19:12:32 по московскому времени (UTC+3)): `2023-08-31T19:12:32+03:00`

    ![Некорректный формат времени](https://github.com/PoorMercymain/user-segmenter/assets/67076111/914c0561-032a-457c-aad4-a31d63be6089)

    Если передан некорректный формат времени - Bad Request

- **Запрос чтения активных сегментов пользователя**

    `GET http://localhost:8080/api/user/{id}`

    ![Запрос чтения активных сегментов пользователя](https://github.com/PoorMercymain/user-segmenter/assets/67076111/ec41adda-8d10-4520-92f3-ce086bdcb2bb)

    Принимается id пользователя в качестве параметра пути (в данном случае - 1), выдает список активных сегментов пользователя. Когда сегментов очень много, и клиент готов принимать сжатые по gzip ответы, тело ответа сжимается по gzip

    ![Запрос чтения сегментов несуществующего пользователя](https://github.com/PoorMercymain/user-segmenter/assets/67076111/8d94283d-3ffa-49f3-a24f-991e55966ee2)

    Если пользователя с запрашиваемым id нет - выдает Not Found

    ![Запрос чтения сегментов пользователя, у которого их нет](https://github.com/PoorMercymain/user-segmenter/assets/67076111/4edf59ec-d95a-4c77-9a40-6a447869c51b)

    Если у пользователя нет активных сегментов - статус код No Content

    Если произошла внутренняя ошибка сервера - выдает Internal Server Error

- **Запрос формирования отчета по добавлениям/удалениям пользователя из сегментов**

    `GET http://localhost:8080/api/user-history/{id}?start=2023-9&end=2023-10`

    ![Простой запрос формирования отчета](https://github.com/PoorMercymain/user-segmenter/assets/67076111/6b50a54e-c82f-49ca-bb73-f57518ff6ea0)

    Обязательный параметр - id пользователя (параметр пути). Без указания интервалов выдает всю историю добавлений и удалений с 1970 года по текущий момент времени, и выдает ссылку на отчет

    ![Запрос формирования отчета по конкретному месяцу](https://github.com/PoorMercymain/user-segmenter/assets/67076111/2f4a0d53-9753-4185-b02f-75037c68fb84)

    Указав query параметр `exact` можно получить ссылку на отчет по конкретному месяцу. Формат времени указывается как `ГГГГ-ММ`

    ![Запрос формирования отчета по конкретный месяц](https://github.com/PoorMercymain/user-segmenter/assets/67076111/00549ee1-a9fb-41cb-b007-945e4b5f9d9d)

    Указав query параметр `end` в формате `ГГГГ-ММ` можно получить ссылку на отчет с выборкой истории с ограничением по времени сверху определенным месяцем включительно (т.е. с 1970 года по `end`)

    ![Запрос формирования отчета с конкретного месяца](https://github.com/PoorMercymain/user-segmenter/assets/67076111/174ef488-f695-4281-bc63-a8684a5c0d63)

    Указав query параметр `start` в формате `ГГГГ-ММ` можно получить ссылку на отчет, с выборкой истории с ограничением по времени снизу определенным месяцем включительно (т.е. со `start` по текущий момент времени)

    ![Запрос формирования отчета по определенному интервалу времени](https://github.com/PoorMercymain/user-segmenter/assets/67076111/b4304ef1-b778-4054-85dc-ebd7abf15fe9)

    Параметры `start` и `end` можно комбинировать, чтобы получать ссылку на отчет по определенному интервалу времени

    ![Неправильное использование start и end](https://github.com/PoorMercymain/user-segmenter/assets/67076111/568bf52b-c22a-4ea9-ba22-15cc089433b7)

    Но если `start` будет больше (позже) `end`, то будет Bad Request

    ![Start с exact](https://github.com/PoorMercymain/user-segmenter/assets/67076111/a16afcca-e518-43ee-8161-451608b19472)

    Если использовать `start` или `end` вместе с `exact`, будет Bad Request

    ![Несуществующий пользователь](https://github.com/PoorMercymain/user-segmenter/assets/67076111/254e5bad-118a-4a9b-adc6-fb432669623a)

    Если запросить отчет по сегментам несуществующего пользователя - будет Not Found

    Если произошла внутренняя ошибка сервера - будет Internal Server Error

- **Запрос чтения отчета по истории добавлений/удалений пользователя из сегментов**

    `GET http://localhost:8080/api/reports/{report_filename}`

    ![Чтение отчета](https://github.com/PoorMercymain/user-segmenter/assets/67076111/d034793c-f637-406b-9a14-1906e1f93919)

    Указав в качестве параметра пути название файла с отчетом, можно получить его в формате csv

    ![Чтение пустого отчета](https://github.com/PoorMercymain/user-segmenter/assets/67076111/ac614893-ec7b-4ea4-9d7d-2b3dbc905a8b)

    Если в отчете нету строк - выдается No Content

    ![Неверное название отчета](https://github.com/PoorMercymain/user-segmenter/assets/67076111/7b0681d8-c906-4173-8bea-d4b5a82fd517)

    При указании названия отчета, не соответствующего формату, получается Bad Request. Ссылку на чтение отчета можно получить из эндпойнта, который был предыдущим в этом ридми

    ![Несуществующий отчет](https://github.com/PoorMercymain/user-segmenter/assets/67076111/f12a6288-f717-4959-8028-8fa24baa6cd2)

    При запросе отчета, который не существует - Not Found

    При внутренней ошибке сервера - Internal Server Error

# Что в итоге
- ✓ **Основное задание**
    - ✓ Метод создания сегмента;
    - ✓ Метод удаления сегмента;
    - ✓ Метод добавления пользователя в сегмент;
    - ✓ Метод получения активных сегментов пользователя;
- ✓ **Опциональные задания**
    - ✓ Отчет в csv;
    - ✓ TTL сегментов пользователя;
    - ✓ Автоматическое добавление процента пользователей в сегмент;
- ✓ **Будет плюсом**
    - ✓ Покрытие кода тестами (+-);
    - ✓ Swagger файл.

